package com.mahmoudjoe3.huffmancoding;
import android.util.Log;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.PriorityQueue;
import java.util.Comparator;

// node class is the basic structure
// of each node present in the Huffman - tree.
class HuffmanNode {
    int data;
    Character c;
    HuffmanNode left;
    HuffmanNode right;
    public HuffmanNode(int data, Character c, HuffmanNode left, HuffmanNode right) {
        this.data = data;
        this.c = c;
        this.left = left;
        this.right = right;
    }
}

// Here we will be compared
// on the basis of data values of the nodes.
class MyComparator implements Comparator<HuffmanNode> {
    public int compare(HuffmanNode x, HuffmanNode y)
    {
        return x.data - y.data;
    }
}

public class Huffman {


    private static final String TAG ="huffmanEncoder" ;

    public static String encode(String word){
        double code=0.0;
        List<Character> distinctChars=new ArrayList<>();
        List<Integer> distinctCharsFreq=new ArrayList<>();
        fillCharLists(word,distinctChars,distinctCharsFreq);
        int NumOfDistinctChars=distinctChars.size();
        // creating a priority queue MinHeap.
        // makes a min-priority queue(min-heap).
        PriorityQueue<HuffmanNode> MinHeap =
                new PriorityQueue<HuffmanNode>(NumOfDistinctChars, new MyComparator());

        //fill minheap
        for (int i = 0; i < NumOfDistinctChars; i++) {
            HuffmanNode hn = new HuffmanNode(distinctCharsFreq.get(i),distinctChars.get(i),null,null);
            MinHeap.add(hn);
        }

        // create a root node
        HuffmanNode root = null;

        // Here we will extract the two minimum value
        // from the heap each time until
        // its size reduces to 1, extract until
        // all the nodes are extracted.
        while (MinHeap.size() > 1) {

            // first min extract.(leftNode)
            HuffmanNode left = MinHeap.peek();
            MinHeap.poll();

            // second min extarct.(RightNode)
            HuffmanNode right = MinHeap.peek();
            MinHeap.poll();

            // new node TopNode which is equal
            HuffmanNode TopNode = new HuffmanNode(left.data + right.data,'-',left,right);

            // marking the TopNode node as the root node.
            root = TopNode;

            // add this node to the priority-queue.
            MinHeap.add(TopNode);
        }

        // print the codes by traversing the tree
        Map<Character,String> symbolWithCodeMap=new HashMap<>();

        TraversTreeForCode(root, "",symbolWithCodeMap);

        String strCode=makeCode(word,symbolWithCodeMap);
        //here we have ex.. [{'a',010},{'m',0000},....]
        Log.d(TAG, "encode:  "+symbolWithCodeMap.toString());
        return strCode;
    }

    private static void fillCharLists(String word, List<Character> distinctChars, List<Integer> distinctCharsFreq) {
        distinctChars.add(word.charAt(0));
        distinctCharsFreq.add(1);
        for(int i=1;i<word.length();i++){
            if(distinctChars.contains(word.charAt(i))){
                int index=distinctChars.indexOf(word.charAt(i));
                distinctCharsFreq.set(index,distinctCharsFreq.get(index)+1);
            }
            else {
                distinctChars.add(word.charAt(i));
                distinctCharsFreq.add(1);
            }
        }
    }

    // recursive function to print the
    // huffman-code through the tree traversal.
    // Here Code is the huffman - code generated.
    private static void TraversTreeForCode(HuffmanNode root, String Code, Map<Character,String> SymbolMap) {
        // base case; if the left and right are null
        // then its a leaf node and we print
        // the code Code generated by traversing the tree.
        if (root.left == null
                && root.right == null
                ) {
            // c is the character in the node
            //System.out.println(root.c + ":" + Code);
            SymbolMap.put(root.c,Code);
            return;
        }

        // recursive calls for left and
        // right sub-tree of the generated tree.
        TraversTreeForCode(root.left, Code + "0",SymbolMap);
        TraversTreeForCode(root.right, Code + "1",SymbolMap);
    }


    private static String makeCode(String word, Map<Character, String> symbolWithCodeMap) {
        StringBuilder code= new StringBuilder();
        for(int i=0;i<word.length();i++){
            code.append(symbolWithCodeMap.get(word.charAt(i)));
        }
        return new String(code);
    }



}


